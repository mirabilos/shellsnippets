#!/bin/mksh
# -*- mode: sh -*-
#-
# Copyright © 2022
#	mirabilos <m@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un‐
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person’s immediate fault when using the work as intended.
#-
# Calculates the earth’s cross-quarter days via the JPL Horizons API
# and the quarter days using the golden ratio approach documented by
# http://web.archive.org/web/20170628085124/http://www.astrothek.de/artikel/jahreskreis/jahreskreis_termine.html
#
# The service http://aa.usno.navy.mil/data/docs/EarthSeasons.php had
# (though at less precision) the former but was discontinued.
#
# Output is in BSD calendar(1) format.

unset LANGUAGE
export LC_ALL=C POSIXLY_CORRECT=1
set -ex
: upgrade your mksh should this fail:
set -o noglob -o pipefail +x

myver=0.1
apibase='https://ssd.jpl.nasa.gov/api/horizons.api'
apirq="$apibase?format=json&COMMAND='10'&OBJ_DATA=NO&MAKE_EPHEM=YES&EPHEM_TYPE=OBSERVER&CENTER=500@399&QUANTITIES='2'&REF_SYSTEM=ICRF&CAL_FORMAT=BOTH&ANG_FORMAT=DEG&APPARENT=AIRLESS&TIME_DIGITS=FRACSEC&EXTRA_PREC=YES&CSV_FORMAT=YES"

function die {
	print -ru2 -- "E: $1"
	shift
	for x in "$@"; do
		print -ru2 -- "N: $x"
	done
	exit 1
}

function warn {
	print -ru2 -- "W: $1"
	shift
	for x in "$@"; do
		print -ru2 -- "N: $x"
	done
}

function testforlocaloptions {
	set +e
}
testforlocaloptions
[[ -o errexit ]] || die 'mksh too old'

myua="earthseasons/$myver +https://github.com/mirabilos/shellsnippets/blob/master/mksh/earthseasons"
mydir=$(realpath "$0/..") || die 'cannot get script directory'
test -d earthseasons.cache || mkdir earthseasons.cache || die 'cannot make cache directory'

if curl --fail-with-body file:/// >/dev/null 2>&1; then
	curlparms='--fail-with-body -sSL'
elif curl -f file:/// >/dev/null 2>&1; then
	curlparms='-fsSL'
else
	die 'cURL failed function test'
fi
curlver=$(curl --version 2>/dev/null | sed -ne '2,$d' -e '/^curl /s!!curl/!p') || curlver=
[[ -n $curlver ]] || die 'cannot obtain cURL version'

caching_didonerequest=false
function caching_request {
	local cachekey=$1 rv altreply
	shift
	set +e

	[[ cachekey != [.\~]* ]] || cachekey="+$cachekey"
	REPLY=earthseasons.cache/$cachekey
	altreply=earthseasons.cache/'~'$cachekey

	if [[ -s earthseasons.cache/$cachekey ]]; then
		return 0
	fi

	[[ ! -e $altreply ]] || rm "$altreply" || \
	    die 'cannot remove old reply' "$altreply"
	print -ru2 "I: requesting $cachekey"
	# rate limiting
	if $caching_didonerequest; then
		sleep 1
	else
		caching_didonerequest=true
	fi
	curl $curlparms -A "$myua using $curlver" "$@" >"$altreply"
	rv=$?
	if (( rv == 0 )); then
		mv "$altreply" "$REPLY" || \
		    die 'renaming cURL result' "$altreply"
		return 0
	fi
	REPLY=$altreply
	return $rv
}

function api_request {
	local parm parms rs rv x

	while (( $# )); do
		parm=${2//'%'/%25}
		parm=${parm//';'/%3B}
		parm=${parm//'/'/%2F}
		parm=${parm//'?'/%3F}
		parm=${parm//':'/%3A}
		parm=${parm//'@'/%40}
		parm=${parm//'&'/%26}
		parm=${parm//'='/%3D}
		parm=${parm//'+'/%2B}
		parm=${parm//'$'/%24}
		parm=${parm//','/%2C}
		parm=${parm//$'\t'/%09}
		parm=${parm//' '/%20}
		parm=${parm//'<'/%3C}
		parm=${parm//'>'/%3E}
		parm=${parm//'#'/%23}
		parm=${parm//'"'/%22}
		parm=${parm//'{'/%7B}
		parm=${parm//'}'/%7D}
		parm=${parm//'|'/%7C}
		parm=${parm//\\/%5C}
		parm=${parm//'^'/%5E}
		parm=${parm//'['/%5B}
		parm=${parm//']'/%5D}
		parm=${parm//'`'/%60}
		parm=${parm//\'/%27}
		parm=${parm//$'\n'/%0A}
		parms+="&$1=$parm"
		shift 2
	done

	set +e
	caching_request "$parms" "$apirq$parms"
	rv=$?
	rs=$REPLY
	(( rv == 0 )) || return $rv

	x=$(<"$rs" jq -r .code) || die 'API result is not JSON' "$parms" "$rs"
	if [[ $x != null ]]; then
		warn "API result error code $x"
		return 254
	fi
	x=$(<"$rs" jq -r .error) || die 'API result is not JSON' "$parms" "$rs"
	if [[ $x != null ]]; then
		warn "API result error string: $x"
		return 254
	fi
	# unpack
	REPLY=earthseasons.cache/.$parms
	<"$rs" jq -r .result >"$REPLY" || \
	    die 'API result unpacking error' "$parms" "$rs"
}

function api_response {
	local rv

	set +e
	api_request "$@"
	rv=$?
	(( rv )) || return 0

	if jq . <"$REPLY" >/dev/null; then
		jq . <"$REPLY" || cat "$REPLY"
	else
		cat "$REPLY"
	fi | sed 's/^/N: /'
	die 'API request failed' "$REPLY"
}

function doapi {
	api_response \
	    START_TIME "'${tbeg%.[05]00}'" \
	    STOP_TIME "'${tend%.[05]00}'" \
	    STEP_SIZE "'$step'"
}

function parse_table {
	nameref dts=${1}ts dec=${1}dec dea=${1}deca nd=${1}n
	local src=$2 tarr line
	set -A dts
	set -A dec
	nd=0

	lastparsed=$1
	lastparsedfn=$src

	exec <"$src"
	while IFS= read -r line; do
		[[ $line != '$$SOE' ]] || break
	done
	[[ $line = '$$SOE' ]] || die 'missing table start marker' "$src"
	while IFS=, read -rA tarr; do
		[[ ${tarr[0]} != '$$EOE' ]] || return 0
		line=${tarr[5]%%+( )}
		dec[nd]=${line##+( )}
		[[ ${dec[nd]} = ?(-)?([0-2])[0-9].[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9] ]] || \
		    die 'DEC not in expected format' "$src" "${tarr[@]}"
		dea[nd]=${dec[nd]#-}
		[[ ${dea[nd]} = ??.* ]] || dea[nd]=0${dea[nd]}
		line=${tarr[0]%%+( )}
		IFS=' -'
		set -- ${line##+( )}
		IFS=$' \t\n'
		case $2 {
		(Jan) line=01 ;;
		(Feb) line=02 ;;
		(Mar) line=03 ;;
		(Apr) line=04 ;;
		(May) line=05 ;;
		(Jun) line=06 ;;
		(Jul) line=07 ;;
		(Aug) line=08 ;;
		(Sep) line=09 ;;
		(Oct) line=10 ;;
		(Nov) line=11 ;;
		(Dec) line=12 ;;
		(*) die 'unparsable month' "$src" "${tarr[@]}" ;;
		}
		[[ $1 = $y || $1 = $z ]] || die 'bad year' "$src" "${tarr[@]}"
		[[ $3 = @(0[1-9]|[12][0-9]|3[01]) ]] || \
		    die 'bad day of month' "$src" "${tarr[@]}"
		# note leap seconds cannot occur in the queries we give
		# resolution is ½ second
		[[ $4 = @([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].[05]00 ]] || \
		    die 'bad time' "$src" "${tarr[@]}"
		dts[nd++]="$1-$line-$3 $4"
	done
	die 'missing table end marker' "$src"
}

(( $# == 1 )) || die "Syntax: $0 year"
[[ $1 == @(19[789][0-9]|2[0-9][0-9][0-9]) ]] || die "not a year: $1"
y=$1
z=$((y + 1))

tbeg="${y}-10-01 00:00:00"
tend="${z}-10-01 00:00:00"
step=365
if (( (z % 4) == 0 && ((z % 100) != 0 || (z % 400) == 0) )); then
	step=366
fi
yearf=${|doapi;}
parse_table year "$yearf"

function dumpx {
	local title=$1 key=$2 fn=$3
	nameref ts=${key}ts dec=${key}dec deca=${key}deca n=${key}n

	print -ru2 -- "I: $title $key file $fn"
	print -ru2 -- "N: i	ts			DEC		DEC absolute"
	i=-1
	while (( ++i < n )); do
		print -ru2 -- "N: $i	${ts[i]}	${dec[i]}	${deca[i]}"
	done
}

function ddie {
	dumpx lastparsed "$lastparsed" "$lastparsedfn"
	die "$@"
}

# find DECmin, DECmax, DECpos, DECneg
i=0
DECmin=err
DECmax=err
while (( ++i < yearn )); do
	if [[ ${yeardeca[i]} < ${yeardeca[i - 1]} ]]; then
		DECmin=$i
		break
	fi
done
while (( i < yearn )) && [[ ${yeardec[++i]} = -* ]]; do
	: nothing
done
DECpos=$i
while (( ++i < yearn )); do
	if [[ ${yeardeca[i]} < ${yeardeca[i - 1]} ]]; then
		DECmax=$i
		break
	fi
done
while (( i < yearn )) && [[ ${yeardec[++i]} != -* ]]; do
	: nothing
done
DECneg=$i
if (( i >= yearn )) || [[ $DECmin = err || $DECmax = err ]]; then
	ddie 'year data format error' \
	    "DECmin=$DECmin" "DECpos=$DECpos" \
	    "DECmax=$DECmax" "DECneg=$DECneg"
fi

function dominmax {
	nameref dec=DEC$1
	local i j k

	(( dec >= 2 )) || ddie huh? "$yearf"	# cannot happen

	tbeg=${yearts[dec - 2]}
	tend=${yearts[dec]}
	step=1200
	nameref f=${1}fcoarse n=c${1}n
	f=${|doapi;}
	parse_table c$1 "$f"
	nameref n=c${1}n ts=c${1}ts dec=c${1}dec deca=c${1}deca

	i=0
	while (( ++i < n )); do
		if [[ ${deca[i]} < ${deca[i - 1]} ]]; then
			break
		fi
	done
	# note that i < 2 cannot happen because deca[dec-1] > deca[dec-2]
	(( i >= 2 )) || ddie huh? "$f"
	(( i < n )) || ddie "cannot determine coarse $1 ranges"

	tbeg=${ts[i - 2]}
	tend=${ts[i]}
	step=576
	nameref f=${1}ffine n=f${1}n
	f=${|doapi;}
	parse_table f$1 "$f"
	nameref n=f${1}n ts=f${1}ts dec=f${1}dec deca=f${1}deca

	i=0
	while (( ++i < n )); do
		if [[ ${deca[i]} < ${deca[i - 1]} ]]; then
			break
		fi
	done
	(( i < n )) || ddie "cannot determine fine $1 range upper end"
	nameref val=vdec$1
	val=${dec[i - 1]}

	j=-1
	while (( ++j < i )); do
		if [[ ${dec[j]} = $val ]]; then
			break
		fi
	done
	if (( j == 0 )); then
		nameref f=${1}fcoarse
		dumpx coarse c$1 "$f"
		ddie "cannot determine fine $1 range lower end"
	fi
	(( j < i )) || ddie huh? "$f" "j=$j i=$i n=$n val=$val"

	# determine median element (j is first $val, i is first after)
	(( (k = (i - j) / 2 + j), 1 ))
	nameref vts=vts$1
	vts=${ts[k]}
}

dominmax min
dominmax max




i=-1
while (( ++i < yearn )); do
	print -r -- "$i	${yearts[i]}	${yeardec[i]}	${yeardeca[i]}"
done
print -r = "$yearf"

print -r -- "$DECmin	${yearts[DECmin]}	${yeardec[DECmin]}	${yeardeca[DECmin]}	min"
print -r -- "$DECpos	${yearts[DECpos]}	${yeardec[DECpos]}	${yeardeca[DECpos]}	pos"
print -r -- "$DECmax	${yearts[DECmax]}	${yeardec[DECmax]}	${yeardeca[DECmax]}	max"
print -r -- "$DECneg	${yearts[DECneg]}	${yeardec[DECneg]}	${yeardeca[DECneg]}	neg"

print -r -- "min: $vtsmin	$vdecmin"
print -r -- "max: $vtsmax	$vdecmax"
