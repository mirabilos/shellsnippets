# $MirOS: src/bin/mksh/dot.mkshrc,v 1.60 2011/05/29 02:18:49 tg Exp $
#-
# Copyright (c) 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2010, 2011
#	Thorsten Glaser <tg@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un-
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person's immediate fault when using the work as intended.
#-
# RFC compliant base64 encoder and decoder

# NUL safe base64 decoder
function Lb64decode {
	[[ -o utf8-mode ]]; typeset u=$?
	set +U
	typeset c s="$*" t=
	[[ -n $s ]] || { s=$(cat;print x); s=${s%x}; }
	typeset -i i=0 n=${#s} p=0 v x
	typeset -i16 o

	while (( i < n )); do
		c=${s:(i++):1}
		case $c {
		(=)	break ;;
		([A-Z])	(( v = 1#$c - 65 )) ;;
		([a-z])	(( v = 1#$c - 71 )) ;;
		([0-9])	(( v = 1#$c + 4 )) ;;
		(+)	v=62 ;;
		(/)	v=63 ;;
		(*)	continue ;;
		}
		(( x = (x << 6) | v ))
		case $((p++)) {
		(0)	continue ;;
		(1)	(( o = (x >> 4) & 255 )) ;;
		(2)	(( o = (x >> 2) & 255 )) ;;
		(3)	(( o = x & 255 ))
			p=0
			;;
		}
		t=$t\\x${o#16#}
	done
	print -n $t
	(( u )) || set -U
}

set -A Lb64encode_code -- A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
    a b c d e f g h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9 + /
if true; then
# not NUL safe base64 encoder
function Lb64encode {
	[[ -o utf8-mode ]]; typeset u=$?
	set +U
	typeset c s="$*" t
	[[ -n $s ]] || { s=$(cat;print x); s=${s%x}; }
	typeset -i i=0 n=${#s} j v

	while (( i < n )); do
		c=${s:(i++):1}
		(( v = 1#$c << 16 ))
		c=${s:(i++):1}
		(( j = ${#c} ? 1#$c : 0 ))
		(( v |= j << 8 ))
		c=${s:(i++):1}
		(( j = ${#c} ? 1#$c : 0 ))
		(( v |= j ))
		t=$t${Lb64encode_code[v >> 18]}${Lb64encode_code[v >> 12 & 63]}
		c=${Lb64encode_code[v >> 6 & 63]}
		if (( i <= n )); then
			t=$t$c${Lb64encode_code[v & 63]}
		elif (( i == n + 1 )); then
			t=$t$c=
		else
			t=$t==
		fi
		if (( ${#t} == 76 || i >= n )); then
			print $t
			t=
		fi
	done
	(( u )) || set -U
}
else
# NUL safe base64 encoder, needs mksh R40
function Lb64encode {
	[[ -o utf8-mode ]]; typeset u=$?
	set +U
	typeset c s t
	if (( $# )); then
		read -raN-1 s <<<"$*"
		unset s[${#s[*]}-1]
	else
		read -raN-1 s
	fi
	typeset -i i=0 n=${#s[*]} j v

	while (( i < n )); do
		(( v = s[i++] << 16 ))
		(( j = i < n ? s[i++] : 0 ))
		(( v |= j << 8 ))
		c=${s:(i++):1}
		(( j = i < n ? s[i++] : 0 ))
		(( v |= j ))
		t=$t${Lb64encode_code[v >> 18]}${Lb64encode_code[v >> 12 & 63]}
		c=${Lb64encode_code[v >> 6 & 63]}
		if (( i <= n )); then
			t=$t$c${Lb64encode_code[v & 63]}
		elif (( i == n + 1 )); then
			t=$t$c=
		else
			t=$t==
		fi
		if (( ${#t} == 76 || i >= n )); then
			print $t
			t=
		fi
	done
	(( u )) || set -U
}
fi
