#!/bin/mksh
# $MirOS: contrib/hosted/tg/bdf2jupp,v 1.1 2011/11/20 00:11:04 tg Exp $
#-
# Copyright © 2011
#	Thorsten Glaser <tg@mirbsd.org>
#
# Provided that these terms and disclaimer and all copyright notices
# are retained or reproduced in an accompanying document, permission
# is granted to deal in this work without restriction, including un‐
# limited rights to use, publicly perform, distribute, sell, modify,
# merge, give away, or sublicence.
#
# This work is provided “AS IS” and WITHOUT WARRANTY of any kind, to
# the utmost extent permitted by applicable law, neither express nor
# implied; without malicious intent or gross negligence. In no event
# may a licensor, author or contributor be held liable for indirect,
# direct, other damage, loss, or other issues arising in any way out
# of dealing in the work, even if advised of the possibility of such
# damage or existence of a defect, except proven that it results out
# of said person’s immediate fault when using the work as intended.
#-
# Convert a BDF STARTCHAR‥ENDCHAR block into an editable format

read x charname
if [[ $x != STARTCHAR ]]; then
	print E: no STARTCHAR
	exit 1
fi
set -A lines -- "STARTxCHAR $charname"
integer w=0 h=0
while IFS= read -r line; do
	set -A words -- $line
	case $line {
	(ENCODING\ +([0-9]))
		typeset -Uui16 -Z7 c=${words[1]}
		line="ENCODING U+${c#16#}"
		;;
	(BBX\ +([0-9])\ +([0-9])?( *))
		w=${words[1]}
		h=${words[2]}
		if (( w > 32 )); then
			print E: $w is too wide
			exit 1
		fi
		;;
	}
	lines[${#lines[*]}]=$line
	[[ $line = BITMAP ]] && break
done
if (( w <= 8 )); then
	adds=000000
elif (( w <= 16 )); then
	adds=0000
elif (( w <= 24 )); then
	adds=00
else
	adds=
fi
(( shiftbits = 32 - w ))
(( uw = 2 + w ))
ch=0
while (( ch++ < h )); do
	IFS= read -r line
	if [[ $line != +([0-9A-Fa-f]) ]]; then
		print -r "E: not a valid bitmap line: $line"
		exit 1
	fi
	line=$line$adds
	if (( ${#line} != 8 )); then
		print -r "E: not a valid bitmap line: ${line%$adds}"
		exit 1
	fi
	typeset -Uui2 -Z$uw bbin=16#$line
	(( bbin >>= shiftbits ))
	b=${bbin#2#}
	b=${b//0/.}
	b=${b//1/#}
	lines[${#lines[*]}]=$b
done
IFS= read -r line
if [[ $line != ENDCHAR ]]; then
	print E: no ENDCHAR
	exit 1
fi
for line in "${lines[@]}" ENDxCHAR; do
	print -r -- "$line"
done
exit 0
